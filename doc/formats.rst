.. _file-formats:

Game representation formats
===========================

This section documents the file formats recognized by Gambit. These
file formats are text-based and designed to be readable and editable
by hand by humans to the extent possible, although programmatic tools
to generate and manipulate these files are almost certainly needed for
all but the most trivial of games.

These formats can be viewed as being low-level. They define games
explicitly in terms of their structure, and do not support any sort of
parameterization, macros, and the like. Thus, they are adapted largely
to the type of input required by the numerical methods for computing
Nash equilibria, which only apply to a particular realization of a
game's parameters. Higher-level tools, whether the graphical interface
or scripting applications, are indicated for doing parametric analysis
and the like.



Conventions common to all file formats
--------------------------------------

Several conventions are common to the interpretation of the file
formats listed below.

**Whitespace is not significant.** In general, whitespace (carriage
returns, horizontal and vertical tabs, and spaces) do not have an
effect on the meaning of the file. The only exception is inside
explicit double-quotes, where all characters are significant. The
formatting shown here is the same as generated by the Gambit code and
has been chosen for its readability; other formattings are possible
(and legal).

**Text labels.** Most objects in an extensive game may be given
textual labels. These are prominently used in the graphical interface,
for example, and it is encouraged for users to assign nonempty text
labels to objects if the game is going to be viewed in the graphical
interface. In all cases, these labels are surrounded by the quotation
character ("). The use of an explicit " character within a text label
can be accomplished by preceding the embedded " characters with a
backwards slash (\).
**Example 5-1. Escaping quotes in a text label**

This is an alternate version of the first line of the example file, in
which the title of the game contains the term Bayesian game in
quotation marks.

.. sourcecode:: python

    EFG 2 R "An example of a \"Bayesian game\"" { "Player 1" "Player 2" }




**Numerical data.** yNumerical data, namely, the payoffs at outcomes,
and the action probabilities for chance nodes, may be expressed in
integer, decimal, or rational formats. In all cases, numbers are
understood by Gambit to be exact, and represented as such internally.
For example, the numerical entries 0.1 and 1/10 represent the same
quantity.


In versions 0.97 and prior, Gambit distinguished between floating
point and rational data. In these versions, the quantity 0.1 was
represented interally as a floating-point number. In this case, since
0.1 does not have an exact representation in binary floating point,
the values 0.1 and 1/10 were not identical, and some methods for
computing equilibria could give (slightly) different results for games
using one versus the other. In particular, using rational-precision
methods on games with the floating point numbers could give unexpected
output, since the conversion of 0.1 first to floating-point then to
rational would involve roundoff error. This is largely of technical
concern, and the current Gambit implementation now behaves in such a
way as to give the "expected" result when decimal numbers appear in
the file format.


The extensive game (.efg) file format
-------------------------------------

The extensive game (.efg) file format has been used by Gambit, with
minor variations, to represent extensive games since circa 1994. It
replaced an earlier format, which had no particular name but which had
the conventional extension .dt1. It is intended that some new formats
will be introduced in the future; however, this format will be
supported by Gambit, possibly through the use of converter programs to
those putative future formats, for the foreseeable future.


A sample file
~~~~~~~~~~~~~

This is a sample file illustrating the general format of the file.
This file is similar to the one distributed in the Gambit distribution
under the name bayes1a.efg .

.. sourcecode:: python

    EFG 2 R "General Bayes game, one stage" { "Player 1" "Player 2" }
    c "ROOT" 1 "(0,1)" { "1G" 0.500000 "1B" 0.500000 } 0
    c "" 2 "(0,2)" { "2g" 0.500000 "2b" 0.500000 } 0
    p "" 1 1 "(1,1)" { "H" "L" } 0
    p "" 2 1 "(2,1)" { "h" "l" } 0
    t "" 1 "Outcome 1" { 10.000000 2.000000 }
    t "" 2 "Outcome 2" { 0.000000 10.000000 }
    p "" 2 1 "(2,1)" { "h" "l" } 0
    t "" 3 "Outcome 3" { 2.000000 4.000000 }
    t "" 4 "Outcome 4" { 4.000000 0.000000 }
    p "" 1 1 "(1,1)" { "H" "L" } 0
    p "" 2 2 "(2,2)" { "h" "l" } 0
    t "" 5 "Outcome 5" { 10.000000 2.000000 }
    t "" 6 "Outcome 6" { 0.000000 10.000000 }
    p "" 2 2 "(2,2)" { "h" "l" } 0
    t "" 7 "Outcome 7" { 2.000000 4.000000 }
    t "" 8 "Outcome 8" { 4.000000 0.000000 }
    c "" 3 "(0,3)" { "2g" 0.500000 "2b" 0.500000 } 0
    p "" 1 2 "(1,2)" { "H" "L" } 0
    p "" 2 1 "(2,1)" { "h" "l" } 0
    t "" 9 "Outcome 9" { 4.000000 2.000000 }
    t "" 10 "Outcome 10" { 2.000000 10.000000 }
    p "" 2 1 "(2,1)" { "h" "l" } 0
    t "" 11 "Outcome 11" { 0.000000 4.000000 }
    t "" 12 "Outcome 12" { 10.000000 2.000000 }
    p "" 1 2 "(1,2)" { "H" "L" } 0
    p "" 2 2 "(2,2)" { "h" "l" } 0
    t "" 13 "Outcome 13" { 4.000000 2.000000 }
    t "" 14 "Outcome 14" { 2.000000 10.000000 }
    p "" 2 2 "(2,2)" { "h" "l" } 0
    t "" 15 "Outcome 15" { 0.000000 4.000000 }
    t "" 16 "Outcome 16" { 10.000000 0.000000 }




Structure of the prologue
~~~~~~~~~~~~~~~~~~~~~~~~~

The extensive gamefile consists of two parts: the prologue, or header,
and the list of nodes, or body. In the example file, the prologue is
the first line. (Again, this is just a consequence of the formatting
we have chosen and is not a requirement of the file structure itself.)

The prologue is constructed as follows. The file begins with the token
EFG , identifying it as an extensive gamefile. Next is the digit 2 ;
this digit is a version number. Since only version 2 files have been
supported for more than a decade, all files have a 2 in this position.
Next comes the letter R . The letter R used to distinguish files which
had rational numbers for numerical data; this distinction is obsolete,
so all new files should have R in this position.

The prologue continues with the title of the game. Following the title
is a list of the names of the players defined in the game. This list
follows the convention found elsewhere in the file of being surrounded
by curly braces and delimited by whitespace (but not commas,
semicolons, or any other character). The order of the players is
significant; the first entry in the list will be numbered as player 1,
the second entry as player 2, and so forth.  At the end of the prologue
is an optional text comment field.



Structure of the body (list of nodes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The body of the file lists the nodes which comprise the game tree.
These nodes are listed in the prefix traversal of the tree. The prefix
traversal for a subtree is defined as being the root node of the
subtree, followed by the prefix traversal of the subtree rooted by
each child, in order from first to last. Thus, for the whole tree, the
root node appears first, followed by the prefix traversals of its
child subtrees. For convenience, the game above follows the convention
of one line per node.

Each node entry begins with an unquoted character indicating the type
of the node. There are three node types:



+ c for a chance node
+ p for a personal player node
+ t for a terminal node

Each node type will be discussed individually below. There are three
numbering conventions which are used to identify the information
structure of the tree. Wherever a player number is called for, the
integer specified corresponds to the index of the player in the player
list from the prologue. The first player in the list is numbered 1,
the second 2, and so on. Information sets are identified by an
arbitrary positive integer which is unique within the player. Gambit
generates these numbers as 1, 2, etc. as they appear first in the
file, but there are no requirements other than uniqueness. The same
integer may be used to specify information sets for different players;
this is not ambiguous since the player number appears as well.
Finally, outcomes are also arbitrarily numbered in the file format in
the same way in which information sets are, except for the special
number 0 which indicates the null outcome.

Information sets and outcomes may (and frequently will) appear
multiple times within a game. By convention, the second and subsequent
times an information set or outcome appears, the file may omit the
descriptive information for that information set or outcome.
Alternatively, the file may specify the descriptive information again;
however, it must precisely match the original declaration of the
information set or outcome. If any part of the description is omitted,
the whole description must be omitted.

Outcomes may appear at nonterminal nodes. In these cases, payoffs are
interepreted as incremental payoffs; the payoff to a player for a
given path through the tree is interpreted as the sum of the payoffs
at the outcomes encountered on that path (including at the terminal
node). This is ideal for the representation of games with well-
defined"stages"; see, for example, the file bayes2a.efg in the Gambit
distribution for a two-stage example of the Bayesian game represented
previously.

In the following lists, fields which are omittable according to the
above rules are indicated by the label (optional).

**Format of chance (nature) nodes.** Entries for chance nodes begin
with the character c . Following this, in order, are



+ a text string, giving the name of the node
+ a positive integer specifying the information set number
+ (optional) the name of the information set
+ (optional) a list of actions at the information set with their
  corresponding probabilities
+ a nonnegative integer specifying the outcome
+ (optional)the payoffs to each player for the outcome



**Format of personal (player) nodes.** Entries for personal player
decision nodes begin with the character p . Following this, in order,
are:



+ a text string, giving the name of the node
+ a positive integer specifying the player who owns the node
+ a positive integer specifying the information set
+ (optional) the name of the information set
+ (optional) a list of action names for the information set
+ a nonnegative integer specifying the outcome
+ (optional) the name of the outcome
+ the payoffs to each player for the outcome



**Format of terminal nodes.** Entries for terminal nodes begin with
the character t . Following this, in order, are:



+ a text string, giving the name of the node
+ a nonnegative integer specifying the outcome
+ (optional) the name of the outcome
+ the payoffs to each player for the outcome



There is no explicit end-of-file delimiter for the file.



The strategic game (.nfg) file format, payoff version
-----------------------------------------------------

This file format defines a strategic N-player game. In this version,
the payoffs are listed in a tabular format. See the next section for a
version of this format in which outcomes can be used to identify an
equivalence among multiple strategy profiles.



A sample file
~~~~~~~~~~~~~

This is a sample file illustrating the general format of the file.
This file is distributed in the Gambit distribution under the name
e02.nfg .

.. sourcecode:: python

    NFG 1 R "Selten (IJGT, 75), Figure 2, normal form" 
    { "Player 1" "Player 2" } { 3 2 }
    
    1 1 0 2 0 2 1 1 0 3 2 0 




Structure of the prologue
~~~~~~~~~~~~~~~~~~~~~~~~~

The prologue is constructed as follows. The file begins with the token
NFG , identifying it as a strategic gamefile. Next is the digit 1 ;
this digit is a version number. Since only version 1 files have been
supported for more than a decade, all files have a 1 in this position.
Next comes the letter R . The letter R used to distinguish files which
had rational numbers for numerical data; this distinction is obsolete,
so all new files should have R in this position.

The prologue continues with the title of the game. Following the title
is a list of the names of the players defined in the game. This list
follows the convention found elsewhere in the file of being surrounded
by curly braces and delimited by whitespace (but not commas,
semicolons, or any other character). The order of the players is
significant; the first entry in the list will be numbered as player 1,
the second entry as player 2, and so forth.

Following the list of players is a list of positive integers. This
list specifies the number of strategies available to each player,
given in the same order as the players are listed in the list of
players.

The prologue concludes with an optional text comment field.


Structure of the body (list of payoffs)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The body of the format lists the payoffs in the game. This is a "flat"
list, not surrounded by braces or other punctuation.

The assignment of the numeric data in this list to the entries in the
strategic game table proceeds as follows. The list begins with the
strategy profile in which each player plays their first strategy. The
payoffs to all players in this contingency are listed in the same
order as the players are given in the prologus. This, in the example
file, the first two payoff entries are 1 1 , which means, when both
players play their first strategy, player 1 receives a payoff of 1,
and player 2 receives a payoff of 1.

Next, the strategy of the first player is incremented. Thus, player
1's strategy is incremented to his second strategy. In this case, when
player 1 plays his second strategy and player 2 his first strategy,
the payoffs are 0 2 : a payoff of 0 to player 1 and a payoff of 2 to
player 2.

Now the strategy of the first player is again incremented. Thus, the
first player is playing his third strategy, and the second player his
first strategy; the payoffs are again 0 2 .

Now, the strategy of the first player is incremented yet again. But,
the first player was already playing strategy number 3 of 3. Thus, his
strategy now "rolls over" to 1, and the strategy of the second player
increments to 2. Then, the next entries 1 1 correspond to the payoffs
of player 1 and player 2, respectively, in the case where player 1
plays his second strategy, and player 2 his first strategy.

In general, the ordering of contingencies is done in the same way that
we count: incrementing the least-significant digit place in the number
first, and then incrementing more significant digit places in the
number as the lower ones "roll over." The only differences are that
the counting starts with the digit 1, instead of 0, and that the
"base" used for each digit is not 10, but instead is the number of
strategies that player has in the game.


The strategic game (.nfg) file format, outcome version
------------------------------------------------------

This file format defines a strategic N-player game. In this version,
the payoffs are defined by means of outcomes, which may appear more
than one place in the game table. This may give a more compact means
of representing a game where many different strategy combinations map
to the same consequences for the players. For a version of this format
in which payoffs are listed explicitly, without identification by
outcomes, see the previous section.



A sample file
~~~~~~~~~~~~~

This is a sample file illustrating the general format of the file.
This file defines the same game as the example in the previous
section.

.. sourcecode:: python

    NFG 1 R "Selten (IJGT, 75), Figure 2, normal form" { "Player 1" "Player 2" }
    
    {
    { "1" "2" "3" }
    { "1" "2" }
    }
    
    {
    { "" 1, 1 }
    { "" 0, 2 }
    { "" 0, 2 }
    { "" 1, 1 }
    { "" 0, 3 }
    { "" 2, 0 }
    }
    1 2 3 4 5 6




Structure of the prologue
~~~~~~~~~~~~~~~~~~~~~~~~~

The prologue is constructed as follows. The file begins with the token
NFG , identifying it as a strategic gamefile. Next is the digit 1 ;
this digit is a version number. Since only version 1 files have been
supported for more than a decade, all files have a 1 in this position.
Next comes the letter R . The letter R used to distinguish files which
had rational numbers for numerical data; this distinction is obsolete,
so all new files should have R in this position.

The prologue continues with the title of the game. Following the title
is a list of the names of the players defined in the game. This list
follows the convention found elsewhere in the file of being surrounded
by curly braces and delimited by whitespace (but not commas,
semicolons, or any other character). The order of the players is
significant; the first entry in the list will be numbered as player 1,
the second entry as player 2, and so forth.

Following the list of players is a list of strategies. This is a
nested list; each player's strategies are given as a list of text
labels, surrounded by curly braces.

The nested strategy list is followed by an optional text comment 
field.

The prologue closes with a list of outcomes. This is also a nested
list. Each outcome is specified by a text string, followed by a list
of numerical payoffs, one for each player defined. The payoffs may
optionally be separated by commas, as in the example file. The
outcomes are implicitly numbered in the order they appear; the first
outcome is given the number 1, the second 2, and so forth.


Structure of the body (list of outcomes)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The body of the file is a list of outcome indices. These are presented
in the same lexicographic order as the payoffs in the payoff file
format; please see the documentation of that format for the
description of the ordering. For each entry in the table, a
nonnegative integer is given, corresponding to the outcome number
assigned as described in the prologue section. The special outcome
number 0 is reserved for the "null" outcome, which is defined as a
payoff of zero to all players. The number of entries in this list,
then, should be the same as the product of the number of strategies
for all players in the game.



The new-style XML file format
-----------------------------

.. note::

   This section describes a provisional new XML-based file format
   based on the one developed for early versions of Game Theory
   Explorer.  It is subject to change (perhaps significantly) and is
   not yet suitable for long-term storage of game data.

   This is based on the report prepared by Karen Bletzer for Google
   Summer of Code 2011.


XML design approach
~~~~~~~~~~~~~~~~~~~

The XML structure for extensive and strategic games should be general
and robust enough to include any and all features currently supported
by the Gambit file formats such that the XML structure could
potentially also be used for Gambit files in the future.  To such an
end the XML structure proposed in this document is informed by the
current Gambit efg and nfg formats, in that all elements supported by
these file formats should also be supported by the gte XML structure
such that lossless data conversion can be achieved between the
formats.

Additionally, the XML structure should separate display information
from data so that different consumers of the data can focus on the
data that is relevant to them.  For example, if a user would like to
compute equilibria for a particular strategic game, they will not need
the display information.

Proposed display elements for the XML representation are not covered
in this document, although the placeholder ``display`` tags will be
included to indicate where this data will be stored in the future.


XML approach: Overview
~~~~~~~~~~~~~~~~~~~~~~

The XML specification outlined in this document builds on the existing
Game Theory Explorer XML specification.  Differences between the
specifications are briefly explored at the end.  In this section we
focus on discussing the XML structure and how it supports
communication of the game data.

Each XML document must have a root element that signals the beginning
of the document's information.  In this case we will choose ``gte`` as the
root element. The gte root can have five possible children.

The first child is the game description.  The game description element
contains text describing the game.  This element maps directly to the
game description element within the efg and nfg file formats, and
should be present for all documents, although the contents may be
blank.

The next child of gte, the players element, explicitly defines the
name and ordering of each player.  This element is required in all gte
XML output.

The third child of gte contains information regarding how the game
should be displayed on a UI.  How the XML for the display should be
formatted will not be covered in this document, but will be addressed
at a later time.  However, in this document the display tags are shown
as a placeholder in some contexts.

The remaining two child elements represent the type of game, extensive
or strategic, and are an either/or choice for a particular
document. One document cannot represent both an extensive and a
strategic game.

As an example, the beginning formulation of an extensive game would
look as follows, where "..." represents elements that will be filled in
as we proceed exploring the structure.

.. code-block:: guess

   <gte version="0.1">
     <gameDescription>Untitled Extensive Game</gameDescription>
        <players>
           <player playerId="1">Player 1</player>
           <player playerId="2">Player 2</player>
        </players>
     <display></display>
     <extensiveForm>
        ...
     </extensiveForm>
   </gte>

The beginning formulation of a strategic game is similar, except the
extensiveForm tag is replaced by the strategicForm tag.


.. code-block:: guess

   <gte version="0.1">
     <gameDescription>Untitled Strategic Game</gameDescription>
        <players>
           <player playerId="1">Player 1</player>
           <player playerId="2">Player 2</player>
        </players>
     <display></display>
     <strategicForm>
        ...
     </strategicForm>
   </gte>

Extensive games
~~~~~~~~~~~~~~~

Let's first explore the information that makes up the extensive game,
starting from the smallest building block: outcome.

Outcomes
########

A terminal node represents a node in the game tree that has
no children.  A simple terminal node with no payoff is represented by
the ``outcome`` element.  In fully defined games outcomes are likely
to contain player payoffs. An payoff for Player 1 in a game can be
represented as:

.. code-block:: guess

   <payoff player="Player 1">5</payoff>

Note that the element has a payoff content of 5, indicating that the
payoff for Player 1 has the value 5.  Payoffs may be child elements of
the outcome element.

A terminal node with payoff for a two-player game with payoff 5 for
Player 1 and payoff 7 for Player 2 would look as follows:

.. code-block:: guess

   <outcome>
     <payoff player="Player 1">5</payoff>
     <payoff player="Player 2">7</payoff>
   </outcome>


As mentioned earlier, each node in an efg file has an outcome id.  If
the outcome id is zero, that is the null outcome.  This does not need
to be represented in the XML.  However, if the outcome id is greater
than 1 this will be represented in the XML as an attribute with name
``outcomeId``:

.. code-block:: guess

   <outcome outcomeId="1">
     <payoff player="Player 1">5</payoff>
     <payoff player="Player 2">7</payoff>
   </outcome>

Note that the payoff elements can be repeated to communicate the
payoffs for any and all number of players participating in an
extensive game.

Nodes
#####

Both a chance node and a player (decision) node are represented by the
same element: ``node``.

The attributes of the node define what type of data the node
represents.  Node attributes include the iset, outcome, and player.
The attributes define the information at the node itself, as well as
potentially information about its parent.  For example, if a node has
an associated probability, its parent node was a chance node, and its
siblings are also chance nodes with associated probabilities.  As
another example, if a node contains either iset name or number, we
know the node is part of an iset.

.. figure:: figures/gte-sample-1.*
            :alt: A simple game created with GTE.
            :align: center
 
In the extensive game shown in the figure the root node represents a
player node with two possible moves.  Each move results in different
payoffs to the two players participating in the game.  This 
scenario can be represented in an efg file as follows:

.. code-block:: guess

   EFG 2 R "Two Choices" { "Player 1" "Player 2" }
   ""

   p "root" 1 1 "" { "c1" "c2" } 0
   t "result1" 1 "" { 7, 9 }
   t "result2" 2 "" { 24, 2 }

The corresponding XML, omitting the gte and initial game description
elements for brevity, is


.. code-block:: guess

   <node iset="1" nodeName="root" player="Player 1">
     <outcome move="c1" nodeName="result1">
       <payoff player="1">7</payoff>
       <payoff player="2">9</payoff>
     </outcome>
     <outcome move="c2" nodeName="result2">
       <payoff player="1">24</payoff>
       <payoff player="2">2</payoff>
     </outcome>
   </node>


Some observations about the above XML. The root node contains
attributes to represent the player that is making the decision as well
as the iset number that is present in the efg file.  The outcome
elements in the XML have a parent element of node.  The move
information on line 4 of the efg file is associated to the node or
outcome that is a result of that move. That is, "c1" is the name of
the first outcome, and "c2" is the name of the second outcome.  Each
node and outcome in the example has a nodeName.

A similar game is shown in the next figure.  In this case the root
node is a chance node, with the left outcome having a probability of
13/20 and the right outcome having a probability of 7/20.  The payoffs
once again are different based on the move of the root that is
selected by chance.

.. figure:: figures/gte-sample-2.*
            :alt: Simple extensive game with chance node.
            :align: center

The representation of this game in efg format is

.. code-block:: guess

   EFG 2 R "Untitled Extensive Game" { "1" "2" }
   ""

   c "" 1 "" { "m1" 13/20 "m2" 7/20 } 0
   t "" 2 "" { 11, 2 }
   t "" 3 "" { 1, 21 }

The XML for the node data, omitting header elements for brevity, can
be written as

.. code-block:: guess

   <node iset="1">
     <outcome move="m1" prob="13/20" outcomeId="2">
       <payoff player="1">11</payoff>
       <payoff player="2">2</payoff>
     </outcome>
     <outcome move="m2" prob="7/20" outcomeId="3">
       <payoff player="1">1</payoff>
       <payoff player="2">21</payoff>
     </outcome>
   </node>


Note that the nodes in the efg file do not have node names.
Correspondingly, there is no nodeName attribute in the XML.  If an
attribute value does not exist, or has a blank value, it is not be
represented in the XML attributes.  Additionally, note the presence of
the prob attribute in the outcome tag.  This attribute indicates that
the outcome is a result of a chance move that occurred with the given
probability value.  For a game tree the move and probability are data
associated to the edge of the graph, and the remaining attributes such
as player, iset, etc., are data associated to the node itself.  In an
XML representation of the game tree it would be possible to have both
a probability and a player at the same node if the node is a player
decision node, but was a result of a chance move.


Payoffs may be associated to an internal node, and nodes may be nested
to any depth – just as a game tree can have any number of levels.

The following figure represents a more complex example.

.. figure:: figures/gte-sample-3.*
            :alt: Extensive game with information sets, viewed in Gambit.
            :align: center

This game is represented in XML as

.. code-block:: guess

  <gte version="0.1">
    <gameDescription>Sample Game</gameDescription>
    <players>
      <player playerId="1">Player 1</player>
      <player playerId="2">Player 2</player>
    </players>
    <display></display>
    <extensiveForm>
      <node nodeName="root">
        <node iset="1" move="Chance 1" nodeName="P2 - 1" player="Player 2" prob="1/2">
          <payoff player="Player 1">1</payoff>
          <payoff player="Player 2">5</payoff>
          <outcome move="a">
            <payoff player="Player 1">14</payoff>
            <payoff player="Player 2">15</payoff>
          </outcome>
          <node iset="2" move="b" nodeName="P1 - 1" player="Player 1">
            <outcome move="C">
              <payoff player="Player 1">24</payoff>
              <payoff player="Player 2">10</payoff>
            </outcome>
            <outcome move="D">
              <payoff player="Player 1">21</payoff>
              <payoff player="Player 2">19</payoff>
            </outcome>
          </node>
        </node>
        <node iset="1" move="Chance 2" nodeName="P2 - 2" player="Player 2" prob="1/2">
          <payoff player="Player 1">2</payoff>
          <payoff player="Player 2">3</payoff>
          <node iset="3" move="a" nodeName="P1 - 2" player="Player 1">
            <outcome move="E">
              <payoff player="Player 1">2</payoff>
              <payoff player="Player 2">14</payoff>
            </outcome>
            <outcome move="F">
              <payoff player="Player 1">23</payoff>
              <payoff player="Player 2">10</payoff>
            </outcome>
          </node>
          <node iset="3" move="b" nodeName="P1 - 3" player="Player 1">
            <outcome move="E">
              <payoff player="Player 1">2</payoff>
              <payoff player="Player 2">18</payoff>
            </outcome>
            <outcome move="F">
              <payoff player="Player 1">4</payoff>
              <payoff player="Player 2">7</payoff>
            </outcome>
          </node>
        </node>
      </node>
    </extensiveForm>
  </gte>


Strategic games
~~~~~~~~~~~~~~~

A strategic game contains strategy information like an extensive
game. However, since it does not contain nested or tree information it
is more straightforward to represent and map this type of game in XML.
The main concepts communicated in the strategic game are the
strategies and the payoffs.

Starting with the pieces that make up the strategic game XML, the
strategy element contains the labels for a particular player's
strategies. The strategies for a two-player game where each player has
two strategies may be represented by

.. code-block:: guess

   <strategy player="Player 1">{ "1" "2" }</strategy>
   <strategy player="Player 2">{ "1" "2" }</strategy>

We can see the first set of strategy labels belong to Player 1, as
listed in the attributes section of the strategy tag.  This is
consistent with the way player data is represented in extensive games.
The content of the strategy tags are quoted identifiers which
represent the player's strategies in order.  In this way we can
represent strategies for any number of players.  In the first line
above the, we see that Player 1 has two strategies: "1" and "2".
Player 2 also has two strategies, with the same labels as Player 1's
strategies.  If there were more players their strategies would
continue the list.

A player's payoff is listed within the payoffs tag.  The payoffs
follow the same ordering convention as the nfg files.  Below is an
example of player payoffs – each payoff is delimited by whitespace.
Rows are separated by the newline "\n" character.  The payoffs tag is
used for the strategic game, compared to the payoff tag used for the
extensive game.  The two elements are not interchangeable.

.. code-block:: guess

   <payoffs player="Player 1"> 
     2 3 
     5 7
   </payoffs>
   <payoffs player="Player 2"> 
     3 3 
     6 9
   </payoffs>

.. figure:: figures/gte-sample-4.*
            :alt: A three-player game in strategic form.
            :align: center

A complete three person strategic game, depicted above as
displayed by Gambit, can be represented in XML as


.. code-block:: guess

   <gte version="0.1">
     <gameDescription>My untitled game</gameDescription>
       <players>
	 <player playerId="1">Player 1</player>
         <player playerId="2">Player 2</player>
         <player playerId="3">Player 3</player>
       </players>
     <display></display>
     <strategicForm size="{ 3 2 2 }">
       <strategy player="Player 1">{ "c" "d" "e" }</strategy>
       <strategy player="Player 2">{ "1" "2" }</strategy>
       <strategy player="Player 3">{ "A" "B" }</strategy>
       <payoffs player="Player 1"> 
            2 5 1 
            3 7 0 
            0 0 1 
            0 1 7 
       </payoffs>
       <payoffs player="Player 2"> 
            3 6 0 
            3 9 3 
            1 0 1 
            0 1 0 
       </payoffs>
       <payoffs player="Player 3"> 
            1 5 2 
            1 4 0 
            2 7 -1 
            2 -2 5
       </payoffs>
    </strategicForm>
  </gte>


For a two player game the payoff for a player can be represented by an
M x N matrix.  M is the number of rows, or strategies, for the first
player.  N is the number of columns, or strategies, for the second
player.  If there are more than 2 players then there are multiple M x
N matrices representing the payoffs for the strategies of the
additional players.  For a three player game, as above, where the
third player has two strategies, we expect the M x N matrix to be
repeated 2 times; once for each of the third player's strategy.  This
approach can be extrapolated to games for any number of players.

